#include "RF24.h"
#include "SPI.h"

RF24 radio(9,10);
const uint64_t pipe = 0xE6E6E6E6E677;
char rcvMsg[32] = "";
String msg;

#define RowA 2
#define RowB 3
#define RowC 4
#define RowD 5
#define LATCH A2
#define CLK A3

//int latch = A2;
int hc138en = 6;
//int clk = 9;
int Red = 8; //R1
int Green = 7; //G1

int flag = 0;
String logoColor = "";
//byte row = 0;
byte combine[64] = {
  
};

byte blank[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
byte up[] = {
/*--  Up   --*/
/*--  宽x高=16x16   --*/
0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x0F,0x00,0x00,
0x00,0x1F,0xFE,0x00,0x00,0x3F,0xFE,0x00,0x00,0x7F,0xFE,0x00,0x00,0xFF,0xFE,0x00,
0x00,0xFF,0xFE,0x00,0x00,0x7F,0xFE,0x00,0x00,0x3F,0xFE,0x00,0x00,0x1F,0xFE,0x00,
0x00,0x0F,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,
};
byte down[] = {
/*--  Down   --*/
/*--  宽x高=16x16   --*/
0x00,0x00,0x80,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0xF0,0x00,
0x00,0x7F,0xF8,0x00,0x00,0x7F,0xFC,0x00,0x00,0x7F,0xFE,0x00,0x00,0x7F,0xFF,0x00,
0x00,0x7F,0xFF,0x00,0x00,0x7F,0xFE,0x00,0x00,0x7F,0xFC,0x00,0x00,0x7F,0xF8,0x00,
0x00,0x00,0xF0,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x80,0x00,
};
byte left[] = {
/*--  Left   --*/
/*--  宽x高=16x16   --*/
0x00,0xC0,0x06,0x00,0x00,0x60,0x0C,0x00,0x00,0x30,0x18,0x00,0x00,0x18,0x30,0x00,
0x00,0x0C,0x60,0x00,0x00,0x06,0xC0,0x00,0x00,0x03,0x80,0x00,0x00,0x01,0x00,0x00,
0x00,0xC0,0x06,0x00,0x00,0x60,0x0C,0x00,0x00,0x30,0x18,0x00,0x00,0x18,0x30,0x00,
0x00,0x0C,0x60,0x00,0x00,0x06,0xC0,0x00,0x00,0x03,0x80,0x00,0x00,0x01,0x00,0x00,/*"未命名文件",0*/
};
byte right[] = {
/*--  Right   --*/
/*--  宽x高=16x16   --*/
0x00,0x01,0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x06,0xC0,0x00,0x00,0x0C,0x60,0x00,
0x00,0x18,0x30,0x00,0x00,0x30,0x18,0x00,0x00,0x60,0x0C,0x00,0x00,0xC1,0x06,0x00,
0x01,0x83,0x83,0x00,0x00,0x06,0xC0,0x00,0x00,0x0C,0x60,0x00,0x00,0x18,0x30,0x00,
0x00,0x30,0x18,0x00,0x00,0x60,0x0C,0x00,0x00,0xC0,0x06,0x00,0x01,0x80,0x03,0x00,
};
byte stopSign[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,
0x00,0x0F,0xF0,0x00,0x00,0x1F,0xF8,0x00,0x00,0x1F,0xF8,0x00,0x00,0x1F,0xF8,0x00,
0x00,0x1F,0xF8,0x00,0x00,0x1F,0xF8,0x00,0x00,0x1F,0xF8,0x00,0x00,0x0F,0xF0,0x00,
0x00,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

byte camera[] = {
0xC0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,  
};

byte logo[] = {
0x00,0x00,0x20,0x00,0x20,0x00,0x20,0x3E,0x2F,0xA1,0x2A,0xA6,0xFA,0xAC,0x2A,0xA4,
0x2F,0xFC,0x2A,0xA4,0xFA,0xA6,0x2A,0xA4,0x2F,0xA0,0x20,0x3F,0x20,0x00,0x20,0x00,/*"萬",0*/
0x00,0x02,0x09,0x12,0x29,0x52,0x2D,0x52,0x2B,0x52,0xF9,0xFE,0x2B,0x52,0x2D,0x52,
0x29,0x52,0x09,0x12,0x00,0x04,0x33,0xF8,0x42,0x04,0x02,0x02,0x02,0x00,0x00,0x00,/*"達",1*/
};

byte redDisplay[64] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
byte greenDisplay[64] = {  
0xC0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,
};
byte topLeft[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,  
};
byte topRight[] = {
0xC0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
};
byte bottomLeft[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,  
};
byte bottomRight[] = {
0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
};
String command = "";

void setup() {
  pinMode(RowA, OUTPUT);
  pinMode(RowB, OUTPUT);
  pinMode(RowC, OUTPUT);
  pinMode(RowD, OUTPUT);
  pinMode(hc138en, OUTPUT);
  pinMode(LATCH, OUTPUT);
  pinMode(Red, OUTPUT);
  pinMode(Green, OUTPUT);
  pinMode(CLK, OUTPUT);
  
  Serial.begin(115200);
  radio.begin();
  radio.openReadingPipe(1, pipe);
  radio.startListening();
}

void loop() {

  while (radio.available()) {
    radio.read(&rcvMsg, sizeof(rcvMsg));
    command = String(rcvMsg); 
  }
  if (command.length() > 0) {
      if (GetOrder(command)) {
        command = "";
      } else {
        Serial.println("200 command error\r\n");
        command = "";
      }
  }
  if (flag == 0) {
    display_bicolor(redDisplay, greenDisplay);
  } else if (flag == 1) {
    displayHanzi(logo, logoColor);
  }
  
}

int GetOrder(String command) {
  if (command.startsWith("AR_ON")) {
    String dir = command.substring(command.indexOf(' ')+1, command.indexOf(','));
//  dir is the direction of the arrow
    String f = command.substring(command.indexOf(',')+1, command.length());
    ArrowOn(dir, f);
    command = "";
    return 1;
    
  } else if (command.startsWith("AR_OFF")) {
    String dir = command.substring(command.indexOf(' ')+1, command.length());
    ArrowOff(dir);
    command = "";
    return 1;
  } else if (command.startsWith("LOGO_ON")) {
    String color = command.substring(command.indexOf(' ')+1, command.length());
    LogoOn(color);
    command = "";
    return 1;
  } else if (command.startsWith("GREEN_ON")) {
    String pos = command.substring(command.indexOf(' ')+1, command.length());
    PosSwitch(2,pos);
  } else if (command.startsWith("RED_ON")) {
    String pos = command.substring(command.indexOf(' ')+1, command.length());
    PosSwitch(1,pos);
  } else if (command.startsWith("POS_OFF")) {
    String pos = command.substring(command.indexOf(' ')+1, command.length());
    PosSwitch(0,pos);
  }
  
  else return 0;
}

void ArrowOn(String dir, String f) {
  flag = 0;
  if(dir == "UP") {
    logicalAnd(greenDisplay, camera);
    logicalAnd(redDisplay, camera);
    logicalOr(greenDisplay, up);
  } else if(dir == "DOWN") {
    logicalAnd(greenDisplay, camera);
    logicalAnd(redDisplay, camera);
    logicalOr(greenDisplay, down);
  } else if(dir == "LEFT") {
    logicalAnd(greenDisplay, camera);
    logicalAnd(redDisplay, camera);
    logicalOr(greenDisplay, left);
  } else if(dir == "RIGHT") {
    logicalAnd(greenDisplay, camera);
    logicalAnd(redDisplay, camera);
    logicalOr(greenDisplay, right);
  } else if(dir == "STOP") {
    logicalAnd(greenDisplay, camera);
    logicalAnd(redDisplay, camera);
    logicalOr(redDisplay, stopSign);
  } else Serial.println("200 command error");
  Serial.println("On"+dir+f);
}

void ArrowOff(String dir) {
  flag = 0;
  logicalAnd(greenDisplay, camera);
  logicalAnd(redDisplay, camera);
  Serial.println("Off"+dir);
}

void LogoOn(String colorTemp) {
  flag = 1;
  logoColor = colorTemp;
  Serial.println("logo "+colorTemp);
}

void PosSwitch(int color, String pos) {
  flag = 0;
  if (pos == "TOP_LEFT") {
    if (color == 2) {
      logicalOr(greenDisplay, topLeft);
      logicalAndNon(redDisplay, topLeft);
    }else if(color == 1) {
      logicalOr(redDisplay, topLeft);
      logicalAndNon(greenDisplay, topLeft);
    }
  } else if (pos == "TOP_RIGHT") {
    if (color == 2) {
      logicalOr(greenDisplay, topRight);
      logicalAndNon(redDisplay, topRight);
    }else if(color == 1) {
      logicalOr(redDisplay, topRight);
      logicalAndNon(greenDisplay, topRight);
    }
  } else if (pos == "BOTTOM_LEFT") {
    if (color == 2) {
      logicalOr(greenDisplay, bottomLeft);
      logicalAndNon(redDisplay, bottomLeft);
    }else if(color == 1) {
      logicalOr(redDisplay, bottomLeft);
      logicalAndNon(greenDisplay, bottomLeft);
    }
  } else if (pos == "BOTTOM_RIGHT") {
    if (color == 2) {
      logicalOr(greenDisplay, bottomRight);
      logicalAndNon(redDisplay, bottomRight);
    }else if(color == 1) {
      logicalOr(redDisplay, bottomRight);
      logicalAndNon(greenDisplay, bottomRight);
    }
  } else Serial.println("200 command error\r\n");
}

void hc138scan(byte r) {
  digitalWrite(RowA, (r & 0x01));
  digitalWrite(RowB, (r & 0x02));
  digitalWrite(RowC, (r & 0x04));
  digitalWrite(RowD, (r & 0x08));
}

void hc595senddata2(byte data, byte data2){// 高位在前  反相(1亮0灭)
 for (byte i=0; i<8;i++) {
     digitalWrite(CLK,0);
     if (data & 0x80) {
         digitalWrite(Red, 1);   
     } else {
         digitalWrite(Red, 0);
     }
     if (data2 & 0x80) {
         digitalWrite(Green, 1);   
     } else {
         digitalWrite(Green, 0);
     }
     data=data<<1;
     data2 = data2<<1;
     digitalWrite(CLK,1);
 }
}

void display_bicolor(byte redData[], byte greenData[]) {
  for(int row = 0; row < 16; row++) {
    for(int i = 0; i < 4; i++) {
      hc595senddata2(~(redData[i+row*4]), ~(greenData[i+row*4]));  
    }
    digitalWrite(hc138en, 1);    //关闭显示
    hc138scan(row);         //换行
    digitalWrite(LATCH, 0);      //595刷新
    digitalWrite(LATCH, 1);
    //delayMicroseconds(500) ;   //节电用
    digitalWrite(hc138en, 0);    //开启显示
    delayMicroseconds(10) ;    //刷新频率调,差不多60HZ,1/16间隔
  }
}

void displayHanzi(byte data[], String color) {
  for(int row = 0; row < 16; row++) {
    if(color == "RED") {
      hc595senddata2(~(data[row*2]), ~0x00);  
      hc595senddata2(~(data[row*2+1]), ~0x00);
      hc595senddata2(~(data[row*2+32]), ~0x00);
      hc595senddata2(~(data[row*2+33]), ~0x00);
    } else {
      hc595senddata2(~0x00, ~(data[row*2]));
      hc595senddata2(~0x00, ~(data[row*2+1]));
      hc595senddata2(~0x00, ~(data[row*2+32]));
      hc595senddata2(~0x00, ~(data[row*2+33]));
    }
    
    digitalWrite(hc138en, 1);    //关闭显示
    hc138scan(row);             //换行
    digitalWrite(LATCH, 0);      //595刷新
    digitalWrite(LATCH, 1);
    //delayMicroseconds(500) ;   //节电用
    digitalWrite(hc138en, 0);    //开启显示
    delayMicroseconds(10) ;    //刷新频率调,差不多60HZ,1/16间隔
  }
}

void logicalAnd(byte a[], byte b[]) {
  for (int i = 0; i < 64; i++) {
    a[i] = a[i]&b[i];
  }
}

void logicalOr(byte a[], byte b[]) {
  for (int i = 0; i < 64; i++) {
    a[i] = a[i]|b[i];
  }
}

void logicalAndNon(byte a[], byte b[]) {
  for (int i = 0; i < 64; i++) {
    a[i] = a[i]&(~b[i]);
  }
}
